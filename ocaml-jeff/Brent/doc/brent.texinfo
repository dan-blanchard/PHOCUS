\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename brent.texinfo.info
@settitle 
@c %**end of header
@defcodeindex va
@defcodeindex ty
@defcodeindex mt
@defcodeindex mo
@dircategory Objective Caml
@direntry
* : (brent.texinfo).
@end direntry
@ifinfo
This file was generated by Ocamldoc using the Texinfo generator.
@end ifinfo
@c no titlepage.
@node Top, , , (dir)
@top 
@c no title given
@menu
* S::                              Module
* Brent::                          Module
* Segment::                        Module
* Check::                          Module

Indices :
* Types index::
* Values index::
* Modules index::
* Module types index::
@end menu
@node S,
@chapter Module @code{S}
@moindex S

@section Description
S implements the phoneme-level segments in an utterance as strings. The S
module is of type @code{X.X_TYPE}.

author: Jeff Heinz

last updated : August 2006

@section Interface
@format
@t{
 @minus{} include X.X_TYPE
}
@end format

The following list summarizes the functions in modules of @code{X.X_TYPE}
	which is described in the Tools documentation.  
@itemize
@item
Type @code{t} is a string,i.e. nodes are implemented over strings.  
@item
@code{name} is @code{"Segment"}.  
@item
@code{compare} is the same as @code{Pervasives.compare}.  
@item
@code{pair s1 s2} returns a pair @code{(s1,s2)}.  
@item
@code{of_string} returns a segment from its string representation.  
@item
@code{to_string} returns a string representation of a segment.  
@item
@code{print} prints a segment followed by an endline.  
@item
@code{print_} prints a segment but no endline.
@end itemize

@node Brent,
@chapter Module @code{Brent}
@moindex Brent

@section Description
This module implements the Dynamic Programming Algorithm for    
Probabilistic Utterance Segmentation as described by Brent 1999. 

Full citation: Brent, Michael. 1999. An Efficient, Probabilistically Sound Algorithm 
for Segmentation and Word Discovery. Machine Learning 34, 71-105.     

Authors: Jeff Heinz and Sarah VanWagenen

Last modified: August 2006

@ifinfo
@heading Subparts

@end ifinfo
@menu
* BRENT_TYPE: Brent/BRENT_TYPE.    Module type
* Make: Brent/Make.                Module
@end menu
@section Interface
@format
@t{
 @minus{} module typeBRENT_TYPE}
@end format
@xref{Brent/BRENT_TYPE,Module type BRENT_TYPE}.

The output signature of Make.

@format
@t{
 @minus{} module Make}
@end format
@xref{Brent/Make,Module Make}.

The input signature to Make.

@node Brent/BRENT_TYPE,
@section Module type @code{Brent.BRENT_TYPE}
@mtindex BRENT_TYPE

@subsection Description
The output signature of Make.

@subsection Interface
@format
@t{
 @minus{} type word
}
@end format
@tyindex word

A word is a list of segments.

@format
@t{
 @minus{} val word_of_string :
     string -> word}
@end format
@vaindex word_of_string

Returns a word from its string representation.

@format
@t{
 @minus{} val word_to_string :
     word -> string}
@end format
@vaindex word_to_string

Returns the string representation of a word.

@format
@t{
 @minus{} type utterance
}
@end format
@tyindex utterance

An utterance is a list of words.

@format
@t{
 @minus{} val utterance_of_string :
     string -> utterance}
@end format
@vaindex utterance_of_string

Returns an utterance from its string representation.

@format
@t{
 @minus{} val utterance_to_string :
     utterance -> string}
@end format
@vaindex utterance_to_string

Returns the string representation of an utterance.

@format
@t{
 @minus{} type lexicon
}
@end format
@tyindex lexicon

A lexicon is map from words to floating point values which, in MDBP-1,
represent frequency values.

@format
@t{
 @minus{} val empty_lexicon :
     lexicon}
@end format
@vaindex empty_lexicon

The empty lexicon.

@format
@t{
 @minus{} val print_lexicon :
     ?oc:Pervasives.out_channel -> lexicon -> unit}
@end format
@vaindex print_lexicon

@code{print_lexicon lex} prints a lexicon to output channel @code{oc}. @code{oc} is
optional (default is standard output).

@format
@t{
 @minus{} val lexicon_to_file :
     string -> lexicon -> unit}
@end format
@vaindex lexicon_to_file

@code{lexicon_to_file filename lex} takes a lexicon and writes it to a file.

@format
@t{
 @minus{} val lexicon_of_file :
     string -> lexicon}
@end format
@vaindex lexicon_of_file

@code{lexicon_of_file filename} takes a file with words associated with
floating point numbers and returns a lexicon. Key (words) and data
(number) values in the file must be separated by a single tab '\t'.

@format
@t{
 @minus{} val mdbp1 :
     word ->
       lexicon -> bool -> utterance}
@end format
@vaindex mdbp1

MDBP-1 is the algorithm given in figure 2 on page 91 of Brent 1999.
@code{mdbp1 word lexicon msg} takes a list of segments (with no word
boundaries), and a lexicon, and returns a segmented utterance, that is a
list of words. If @code{msg} is set to @code{true} then MDBP-1 will print each stage
of its processing. (This produces a lot of output so use with care.)


Usage: @code{segmenter ?msg ?infile lexicon} segments a file of unsegmented
      utterances and writes the segmented utterances to the outchannel.  There
      are two optional arguments.  If no infile is given to the function,
      utterance are given via standard input.  If no @code{msg} is given to
      @code{segment} the default is @code{false}. Segmented utterances are written to
      standard output. This function writes the lexicon that exists after
      segmenting all the utterances to the file "lexicon".
@format
@t{
 @minus{} val segmenter :
     ?msg:bool -> ?infile:string -> lexicon -> unit}
@end format
@vaindex segmenter

@node Brent/Make,
@section Module @code{Brent.Make}
@moindex Make

@subsection Description
The input signature to Make.

@subsection Interface
@format
@t{
 @minus{} type word
}
@end format
@tyindex word

A word is a list of segments.

@format
@t{
 @minus{} val word_of_string :
     string -> word}
@end format
@vaindex word_of_string

Returns a word from its string representation.

@format
@t{
 @minus{} val word_to_string :
     word -> string}
@end format
@vaindex word_to_string

Returns the string representation of a word.

@format
@t{
 @minus{} type utterance
}
@end format
@tyindex utterance

An utterance is a list of words.

@format
@t{
 @minus{} val utterance_of_string :
     string -> utterance}
@end format
@vaindex utterance_of_string

Returns an utterance from its string representation.

@format
@t{
 @minus{} val utterance_to_string :
     utterance -> string}
@end format
@vaindex utterance_to_string

Returns the string representation of an utterance.

@format
@t{
 @minus{} type lexicon
}
@end format
@tyindex lexicon

A lexicon is map from words to floating point values which, in MDBP-1,
represent frequency values.

@format
@t{
 @minus{} val empty_lexicon :
     lexicon}
@end format
@vaindex empty_lexicon

The empty lexicon.

@format
@t{
 @minus{} val print_lexicon :
     ?oc:Pervasives.out_channel -> lexicon -> unit}
@end format
@vaindex print_lexicon

@code{print_lexicon lex} prints a lexicon to output channel @code{oc}. @code{oc} is
optional (default is standard output).

@format
@t{
 @minus{} val lexicon_to_file :
     string -> lexicon -> unit}
@end format
@vaindex lexicon_to_file

@code{lexicon_to_file filename lex} takes a lexicon and writes it to a file.

@format
@t{
 @minus{} val lexicon_of_file :
     string -> lexicon}
@end format
@vaindex lexicon_of_file

@code{lexicon_of_file filename} takes a file with words associated with
floating point numbers and returns a lexicon. Key (words) and data
(number) values in the file must be separated by a single tab '\t'.

@format
@t{
 @minus{} val mdbp1 :
     word ->
       lexicon -> bool -> utterance}
@end format
@vaindex mdbp1

MDBP-1 is the algorithm given in figure 2 on page 91 of Brent 1999.
@code{mdbp1 word lexicon msg} takes a list of segments (with no word
boundaries), and a lexicon, and returns a segmented utterance, that is a
list of words. If @code{msg} is set to @code{true} then MDBP-1 will print each stage
of its processing. (This produces a lot of output so use with care.)


Usage: @code{segmenter ?msg ?infile lexicon} segments a file of unsegmented
      utterances and writes the segmented utterances to the outchannel.  There
      are two optional arguments.  If no infile is given to the function,
      utterance are given via standard input.  If no @code{msg} is given to
      @code{segment} the default is @code{false}. Segmented utterances are written to
      standard output. This function writes the lexicon that exists after
      segmenting all the utterances to the file "lexicon".
@format
@t{
 @minus{} val segmenter :
     ?msg:bool -> ?infile:string -> lexicon -> unit}
@end format
@vaindex segmenter

@node Segment,
@chapter Module @code{Segment}
@moindex Segment

@section Description
This is documentation for the command line executable `segment'.

author: Jeff Heinz

last updated: July 30, 2006

@section Interface

This page explains how to use the @code{segment} command line executable which
   implements the Dynamic Programming Algorithm for Probabilistic Utterance
   Segmentation as described in the following paper.  
@itemize
@item
Brent, Michael. 1999. An Efficient, Probabilistically Sound
   Algorithm for Segmentation and Word Discovery. Machine Learning 34, 71-105.
@end itemize


@subsection Usage


@section Invocation


Like other OCaML executables, the program is run by typing @code{./segment} or
     @code{ocamlrun segment} at the command prompt.  Generally it is invoked as follows
     (The @code{./} prefix is omitted for readability).

     @code{segment} @i{options} @i{file}

     If @i{file} is included in the command line, @code{segment} will operate on
     this file. Each line is assumed to be an utterance with the segments
     delimited by some segment delimiter (See options below).

     If @i{file} is not included, then @code{segment} reads from standard
     input. You can indicate that you have finished standard input by entering
     @code{<eof>} on a line by itself or by using @code{^D}.

     The segmented utterances are written to standard output. To put them in a
     file, use redirection. E.g.: 

     @code{segment Alice_in_Wonderland > seg.txt}

@section Options


There are three options.  
@itemize
@item
@code{-sd segment_delimiter} allows you to specify
      how the segments are delimited. The default is the empty string @code{""}.  
@item
@code{-wd segment_delimiter} allows you to specify how the words are
      delimited. The default is a single space @code{" "}.  
@item
@code{-l lexicon} allows you to specify a file that contains a lexicon to be
    used. Each line in a    lexicon file consists of a word and a frequency
    value (positive integer) seperated by a tab.  
@item
@code{-v} prints to standard output every state the algorithm goes through in
    segmenting each utterance, in addition to the segmented utterance.  Use
    with care as each utterance there is quite a bit of output for each
    utterance.
@end itemize

    Example: 

    @code{segment -sd " " -wd "#" Alice_in_Wonderland}

    This command will recognize an utterance as a list of segments separated
    by spaces and will insert the @code{#} mark as word boundaries. This is useful if
    one is using CMUDICT phones for example.
@node Check,
@chapter Module @code{Check}
@moindex Check

@section Description
This is documentation for the command line executable `check.

author: Jeff Heinz

last updated: December 1, 2007

@section Interface

This page explains how to use the @code{check} command line executable which
   measures the precision and recall of segmented text against the gold target
   text. The output is three columns printed to standard out: line no.,
   precision, recall (columns are separated by tabs). 

   Precision and recall are measured in the following manner (see reference
   below for details): Each word in the algorithmic segmentation was labeled a
   true positive if it lines up exactly with a word in the gold
   segmentation---that is, both boundaries match. Each word in the algorithmic
   segmentation which does not align exactly with a word in the standard
   segmentation is counted as a false positive. Each word in the standard
   segmentation which does not align exactly with a word in the algorithmic
   segmentation counts as a false negative. Then:

   precision = true positives / (true positives + false positives)

   recall = true positives / (true positives + false negatives)

@itemize
@item
Brent, Michael. 1999. An Efficient, Probabilistically Sound
   Algorithm for Segmentation and Word Discovery. Machine Learning 34, 71-105.
@end itemize


@subsection Usage


@section Invocation


Like other OCaML executables, the program is run by typing @code{./segment} or
     @code{ocamlrun segment} at the command prompt.  Generally it is invoked as follows
     (The @code{./} prefix is omitted for readability).

     @code{check} @i{options} @i{testfile} @i{goldfile}

     The @code{testfile} is the algorithmically segmented text. The @code{goldfile} is
     the target segmented text. By default, precision and recall are computed
     in 500 line chunks. (This can be adjusted as desired with the option @code{-b}
     (see below).

@section Options


There are three options.  
@itemize
@item
@code{-sd segment_delimiter} allows you to specify
      how the segments are delimited. The default is the empty string @code{""}.  
@item
@code{-wd segment_delimiter} allows you to specify how the words are
      delimited. The default is a single space @code{" "}.  
@item
@code{-b blocksize} allows you to specify the size of the chunks of the file
    which are evaluated for precision and recall.
@end itemize


@node Types index,
@unnumbered Types index
@printindex ty
@node Values index,
@unnumbered Values index
@printindex va
@node Modules index,
@unnumbered Modules index
@printindex mo
@node Module types index,
@unnumbered Module types index
@printindex mt
@contents
@bye
